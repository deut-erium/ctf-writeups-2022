<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/feed.xml" rel="self" type="application/atom+xml" /><link href="https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-05-10T07:25:45+05:30</updated><id>https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/feed.xml</id><title type="html">CTF Writeups</title><subtitle></subtitle><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><entry><title type="html">Sdctf Tasty Crypto Roll</title><link href="https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/sdctf/tasty_crypto_roll/2022-05-10-SDCTF-Tasty-Crypto-Roll" rel="alternate" type="text/html" title="Sdctf Tasty Crypto Roll" /><published>2022-05-10T00:00:00+05:30</published><updated>2022-05-10T00:00:00+05:30</updated><id>https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/sdctf/tasty_crypto_roll/SDCTF-Tasty-Crypto-Roll</id><content type="html" xml:base="https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/sdctf/tasty_crypto_roll/2022-05-10-SDCTF-Tasty-Crypto-Roll"><![CDATA[<h1 id="tasty-crypto-roll">Tasty Crypto Roll</h1>
<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CRYPTO - Hard
Tasty Crypto Roll
Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it.

The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right?
Encrypter
[encrypt.py](encrypt.py)
Encrypted file
[enc.bin](enc.bin)
Note
The intended solution requires very little brute force and runs under 5 seconds on our machine.
By k3v1n
</code></pre></div></div>

<h2 id="source">Source</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">secrets</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>

<span class="n">ENCODING</span> <span class="o">=</span> <span class="s">'utf-8'</span>

<span class="k">def</span> <span class="nf">generate_key</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">secrets</span><span class="p">.</span><span class="n">token_bytes</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cipher</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="n">key1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">generate_key</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Using Key:</span><span class="se">\n</span><span class="si">{</span><span class="n">key1</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">key2</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_flag</span><span class="p">():</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'Enter the flag to encrypt: '</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'sdctf{'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">'}'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">isascii</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">flag</span><span class="si">}</span><span class="s"> is not a valid flag for this challenge'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flag</span>

<span class="n">plaintext</span> <span class="o">=</span> <span class="n">get_flag</span><span class="p">()[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">plaintext</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sboxes</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Bad key, try again"</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">))</span>

<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

<span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>

<span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Encrypted: </span><span class="si">{</span><span class="n">ciphertext</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin2'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ef</span><span class="p">:</span>
    <span class="n">ef</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="analysis">Analysis</h2>
<p>Here we can see mainly two parts</p>
<ol>
  <li>There are two keys
    <ul>
      <li><code class="language-plaintext highlighter-rouge">key1</code>: pid of current process</li>
      <li><code class="language-plaintext highlighter-rouge">key2</code>: secure random key of 16 bytes</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">key1</code> is used as seed at a lot of places and is bruteforcable (&lt; 2^15)
<code class="language-plaintext highlighter-rouge">key_final</code> and <code class="language-plaintext highlighter-rouge">sboxes</code> are derived from <code class="language-plaintext highlighter-rouge">key1</code>, shuffling is done using <code class="language-plaintext highlighter-rouge">key1</code></li>
</ol>

<h3 id="steps-to-crack">Steps to crack</h3>
<ol>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key_final</code></li>
  <li>convert the intermediate ciphertext <code class="language-plaintext highlighter-rouge">to_binary</code></li>
  <li>de-shuffle the bits</li>
  <li>generate <code class="language-plaintext highlighter-rouge">from_binary</code> intermediate ciphertext of the deshuffled bits</li>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key2</code>???</li>
</ol>

<h3 id="how-to-find-key1">How to find <code class="language-plaintext highlighter-rouge">key1</code>?</h3>
<p>Assume you have the correct <code class="language-plaintext highlighter-rouge">key1</code>, reverse for the key, validate the results <br />
using some validator/logical assumption.</p>

<p><code class="language-plaintext highlighter-rouge">codes</code> is a list of <code class="language-plaintext highlighter-rouge">2*(0x1b0-0xb0)</code> = <code class="language-plaintext highlighter-rouge">512</code> characters, utf-8 encoding of
which is 2-bytes each <br />
<code class="language-plaintext highlighter-rouge">sboxes</code> will have 4char strings, which encode to 8 bytes each on utf-8 (i.e
        after substitution)<br />
<code class="language-plaintext highlighter-rouge">data</code> is now <code class="language-plaintext highlighter-rouge">4*2 = 8</code> times each byte of the original plaintext<br />
<code class="language-plaintext highlighter-rouge">data</code> is converted <code class="language-plaintext highlighter-rouge">to_binary</code> before encryption hence each byte is converted<br />
to 8 <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code> byte. Hence each character is substituted to some<br />
<code class="language-plaintext highlighter-rouge">8*8 = 64</code> byte string before encryption.<br />
Hence len of flag = <code class="language-plaintext highlighter-rouge">len(ciphertext)//64</code> = <code class="language-plaintext highlighter-rouge">3520//64 = 55</code> bytes</p>

<h4 id="assumption-1">Assumption 1</h4>
<p>Since length of flag is 55 characters, would it be reasonable to assume that<br />
there would be repeatitions of characters. And since each flag character is<br />
substituted to fixed 64-byte strings before encryption which is a multiple<br />
of AES block size of 16, AES also acts like simple substitution of the flag<br />
but we do not know the mapping.<br />
Hence if we reverse till step 4 above, we can simply check if there are any<br />
repeating 64-byte blocks, as incorrect shuffling of bits will result in each 
block to be distinct with almost 1 probability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>
</code></pre></div></div>

<p>Lets add a few validation too</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1337</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="n">test_unshuffle</span><span class="p">()</span>
<span class="n">test_key_final_dec</span><span class="p">()</span>
</code></pre></div></div>
<p>Looks like all the decryption functions are correct, lets proceed with<br />
bruteforcing for <code class="language-plaintext highlighter-rouge">key1</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>
<p>After waiting for an eternity, and exhausting the search space of possible pidâ€™s<br />
yet not getting any <code class="language-plaintext highlighter-rouge">key1</code> got me confused. I checked my script locally for a <br />
test flag it seemed to work fine. There could only be one possibility <br />
<strong>the flag contains 55 distinct characters</strong><br />
But how would I find <code class="language-plaintext highlighter-rouge">key1</code> now?</p>

<h4 id="missed-catch">Missed Catch</h4>
<p>@Utaha#6878 pointed out, that since there are only 256 distinct values in
<code class="language-plaintext highlighter-rouge">codes</code> each repeated twice, and each character encoded to some <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code><br />
byte strings of length 16, It must be encrypted to the same block always.<br />
Since the flag is <code class="language-plaintext highlighter-rouge">55*4 = 220</code> such 16-byte codes and each code is used twice<br />
for most of the characters, there will be repating 16-byte blocks even with <br />
distinct flag characters.</p>

<h4 id="assumption-2">Assumption 2</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">pid = 83</code></p>
</blockquote>

<p>And we found our <code class="language-plaintext highlighter-rouge">key1</code>!<br />
And we can confirm that the flag is indeed 55 distinct characters.</p>

<p>Wait, if the flag is 55 distinct characters, how will we solve for the subs?<br />
We have no statistical advantage and hence bye bye Mr 
<a href="https://quipqiup.com/">quipquip</a></p>

<h3 id="how-do-we-find-mapping-for-substitution">How do we find mapping for substitution?</h3>
<p>Each <code class="language-plaintext highlighter-rouge">sbox</code> entry is composed of 4 2-byte strings, which can be one of 256<br />
possible values. Moreover, their order is fixed, which is determined by <code class="language-plaintext highlighter-rouge">key1</code>.</p>

<p>If we try to solve for all valid mappings for <code class="language-plaintext highlighter-rouge">AES(binary(sbox(char)))</code> we will
probably end up on the correct mapping and get our flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------------+---------------+------------------------+---------------+
|flag0          |    flag1      |                        |   flag55      |
+---------------+---------------+         ....           +---------------+
|  sbox         |   sbox        |                        |    sbox       |
+---+---+---+---+---+---+---+---+------------------------+---------------+
|c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 |                        |               |
|   |   |   |   |   |   |   |   |                        |               |
+---+---+---+---+---+---+---+---+         ....           +---------------+
|   AES         |    AES        |                        |               |
+---+---+-------+---------------+------------------------+---------------+
|   |   +------+                                                          
|   +--+       |                                                          
+------+-------+-------+------+                                           
|E(c1) | E(c2) | E(c3) | E(c4)|                                             
+------+-------+-------+------+   
</code></pre></div></div>

<h3 id="enter-z3">Enter Z3</h3>
<p>We can assume our flag to be a list of <code class="language-plaintext highlighter-rouge">BitVec</code> of 7 bits each<br />
And let the sboxes be a mapping from 7 bits to 64 bits each (16x4)<br />
This can be achieved by assuming sbox to be an array which is indexed<br />
by <code class="language-plaintext highlighter-rouge">BitVec(7)</code> and contains elements of <code class="language-plaintext highlighter-rouge">BitVec(64)</code><br />
And we assume AES to be some function form <code class="language-plaintext highlighter-rouge">BitVec(16)</code> to <code class="language-plaintext highlighter-rouge">BitVec(128)</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="c1"># keeping sboxes utf encoded already
</span><span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">'big'</span><span class="p">),</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span><span class="mi">2</span><span class="p">))))</span>
<span class="c1"># integer values for 2-byte codes from sbox, will be explained shortly
</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="c1"># converting intermediate decryption to 128 bit ints
</span><span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">],</span><span class="s">'big'</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># we know the sbox already
</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="c1"># splitting 64 bit quantity to 16 bit individual sbox codes
</span>    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">four_code</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="c1"># for each code, matching aes_encryption with the observed value
</span>    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># last but not least, aes_encryption(i) is unique for each plaintext
</span>    <span class="c1"># how would z3 know? Distinct function encodes them appropriately to
</span>    <span class="c1"># be distinct
</span>    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="c1"># lets check for all satisfying flags (in case there are more than one
</span>    <span class="c1"># possible mappings and we will rule out invalid ones in that scenario?
</span>    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span> 
</code></pre></div></div>

<h2 id="flag">Flag</h2>
<p>After running the script, we finally get our flag!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU'</code></p>
</blockquote>

<p>And it turns out to be the only satisfying assignment.<br />
Turns out if there were repeated characters in the flag, we will get multiple<br />
possible satisfying values. So the admins have not been so cheeky afterall</p>

<h2 id="full-script">Full <a href="solve.py">script</a></h2>
<p>Note that it takes a couple of seconds to find the z3 model</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">all_smt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">initial_terms</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sat</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">m</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)):</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">()</span>
                <span class="n">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">initial_terms</span><span class="p">))</span>


<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_unshuffle</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_key_final_dec</span><span class="p">()</span>

<span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">'big'</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span>
    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span> <span class="mi">2</span><span class="p">))))</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="s">'big'</span><span class="p">))</span>

<span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>

<span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">four_code</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="c1"># if solver.check() == sat:
# m = solver.model()
</span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"failed to solve"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="alternate-solution-by-teammate-utaha6878">Alternate Solution by teammate (Utaha#6878)</h3>

<p>All due regards to him for solving the challenge while I was stuck over finding<br />
<code class="language-plaintext highlighter-rouge">key1</code> XD</p>

<p>All parts will be almost same except the substitution solving part, which he<br />
did by manual bruteforcing i.e. recursively enumerating all mappings and
backtracking on contradictions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">codes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)],</span> <span class="n">start</span><span class="o">=</span><span class="p">[])</span> 
<span class="c1"># notice that the range is changed from [0xb0, 0x1b0) to [0, 256). 
# It's just for relabeling.
</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
	<span class="s">"""
	equate two objects elementwise ignoring if the entry is -1
	"""</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">answers</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span> 
<span class="c1"># get the flag based on current mapping, unknown char will be shown as '?'
</span>    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sboxes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">afterMap</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'?'</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span>
    <span class="s">"""
    cip and sboxes remain unchanged throughout the recursive call, 
    but I feel bad using global varaibles.
    """</span>
    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>

    <span class="c1"># check is finished
</span>    <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">isFinished</span><span class="p">:</span>
        <span class="n">answers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Found an answer!!!!!!!"</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># try matching
</span>    <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Find the one with least possible matches.
</span>    <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cip</span><span class="p">):</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">afterMap</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">min_pos</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isContradiction</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># now bruteforce all possibilities
</span>    <span class="k">assert</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="c1"># This is based on the repetition
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">132</span><span class="p">,</span> <span class="mi">197</span><span class="p">]:</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">35</span><span class="p">:</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">109</span><span class="p">:</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">_</span><span class="p">}</span>
    <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Answers:"</span><span class="p">)</span>
<span class="n">answers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">answers</span><span class="p">))</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">answers</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">b</span><span class="s">"sdctf{"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"}"</span><span class="p">)</span>

<span class="c1"># The fourth one is the actual answer
</span></code></pre></div></div>

<blockquote>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ciphertext repetition:
[4, 5, 4, 6]
[34, 35, 36, 35]
[109, 60, 110, 109]
Sbox repetition:
[132, 93, 132, 211]
[197, 32, 197, 248]
[144, 86, 67, 144]
[165, 224, 27, 224]
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Answers:
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
</code></pre></div>  </div>
</blockquote>

<p>full script in <a href="./solve2.py">solve2.py</a></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="cryptography" /><category term="AES" /><category term="z3" /><category term="substitution" /><category term="permutation" /><summary type="html"><![CDATA[Tasty Crypto Roll Description CRYPTO - Hard Tasty Crypto Roll Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it. The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right? Encrypter [encrypt.py](encrypt.py) Encrypted file [enc.bin](enc.bin) Note The intended solution requires very little brute force and runs under 5 seconds on our machine. By k3v1n Source import os import random import secrets import sys from Crypto.Cipher import AES ENCODING = 'utf-8' def generate_key(): return os.getpid(), secrets.token_bytes(16) def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key: bytes, message: bytes): cipher = AES.new(key, AES.MODE_ECB) return cipher.encrypt(message) key1, key2 = generate_key() print(f'Using Key:\n{key1}:{key2.hex()}') def get_flag(): flag = input('Enter the flag to encrypt: ') if not flag.startswith('sdctf{') or not flag.endswith('}') or not flag.isascii(): print(f'{flag} is not a valid flag for this challenge') sys.exit(1) return flag plaintext = get_flag()[6:-1] data = plaintext.encode(ENCODING) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i*4:(i+1)*4]) for i in range(128)] if len(set(sboxes)) &lt; 128: print("Bad key, try again") sys.exit(1) data = ''.join(sboxes[c] for c in data).encode(ENCODING) data = encrypt(key2, to_binary(data).encode(ENCODING)) random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) ciphertext = encrypt(key_final, data) print(f'Encrypted: {ciphertext.hex()}') with open('enc.bin2', 'wb') as ef: ef.write(ciphertext) Analysis Here we can see mainly two parts There are two keys key1: pid of current process key2: secure random key of 16 bytes key1 is used as seed at a lot of places and is bruteforcable (&lt; 2^15) key_final and sboxes are derived from key1, shuffling is done using key1 Steps to crack decrypt using key_final convert the intermediate ciphertext to_binary de-shuffle the bits generate from_binary intermediate ciphertext of the deshuffled bits decrypt using key2??? How to find key1? Assume you have the correct key1, reverse for the key, validate the results using some validator/logical assumption. codes is a list of 2*(0x1b0-0xb0) = 512 characters, utf-8 encoding of which is 2-bytes each sboxes will have 4char strings, which encode to 8 bytes each on utf-8 (i.e after substitution) data is now 4*2 = 8 times each byte of the original plaintext data is converted to_binary before encryption hence each byte is converted to 8 b"0" or b"1" byte. Hence each character is substituted to some 8*8 = 64 byte string before encryption. Hence len of flag = len(ciphertext)//64 = 3520//64 = 55 bytes Assumption 1 Since length of flag is 55 characters, would it be reasonable to assume that there would be repeatitions of characters. And since each flag character is substituted to fixed 64-byte strings before encryption which is a multiple of AES block size of 16, AES also acts like simple substitution of the flag but we do not know the mapping. Hence if we reverse till step 4 above, we can simply check if there are any repeating 64-byte blocks, as incorrect shuffling of bits will result in each block to be distinct with almost 1 probability. with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def unshuffle(data_list, shuffle_order): res = [None]*len(data_list) for i,v in enumerate(shuffle_order): res[v] = data_list[i] return res def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data Lets add a few validation too def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def test_unshuffle(): random_text = list(random.randbytes(16*1337)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(1337) random.shuffle(random_text_shuffled) random.seed(1337) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text def test_key_final_dec(): random_text = random.randbytes(16*100) assert key_final_dec(1337, key_final_enc(1337, random_text)) == random_text test_unshuffle() test_key_final_dec() Looks like all the decryption functions are correct, lets proceed with bruteforcing for key1 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+64] for i in range(0,len(data),64)) if len(substitutions)!=len(data)//64: print("pid =",key1) break After waiting for an eternity, and exhausting the search space of possible pidâ€™s yet not getting any key1 got me confused. I checked my script locally for a test flag it seemed to work fine. There could only be one possibility the flag contains 55 distinct characters But how would I find key1 now? Missed Catch @Utaha#6878 pointed out, that since there are only 256 distinct values in codes each repeated twice, and each character encoded to some b"0" or b"1" byte strings of length 16, It must be encrypted to the same block always. Since the flag is 55*4 = 220 such 16-byte codes and each code is used twice for most of the characters, there will be repating 16-byte blocks even with distinct flag characters. Assumption 2 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+16] for i in range(0,len(data),16)) if len(substitutions)!=len(data)//16: print("pid =",key1) break pid = 83 And we found our key1! And we can confirm that the flag is indeed 55 distinct characters. Wait, if the flag is 55 distinct characters, how will we solve for the subs? We have no statistical advantage and hence bye bye Mr quipquip How do we find mapping for substitution? Each sbox entry is composed of 4 2-byte strings, which can be one of 256 possible values. Moreover, their order is fixed, which is determined by key1. If we try to solve for all valid mappings for AES(binary(sbox(char))) we will probably end up on the correct mapping and get our flag. +---------------+---------------+------------------------+---------------+ |flag0 | flag1 | | flag55 | +---------------+---------------+ .... +---------------+ | sbox | sbox | | sbox | +---+---+---+---+---+---+---+---+------------------------+---------------+ |c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 | | | | | | | | | | | | | | +---+---+---+---+---+---+---+---+ .... +---------------+ | AES | AES | | | +---+---+-------+---------------+------------------------+---------------+ | | +------+ | +--+ | +------+-------+-------+------+ |E(c1) | E(c2) | E(c3) | E(c4)| +------+-------+-------+------+ Enter Z3 We can assume our flag to be a list of BitVec of 7 bits each And let the sboxes be a mapping from 7 bits to 64 bits each (16x4) This can be achieved by assuming sbox to be an array which is indexed by BitVec(7) and contains elements of BitVec(64) And we assume AES to be some function form BitVec(16) to BitVec(128) flag = [BitVec('flag_'+str(i),7) for i in range(len(data)//64)] sboxmap = Array('sbox',BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES',BitVecSort(16), BitVecSort(128)) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) # keeping sboxes utf encoded already sboxes = [''.join(codes[i*4:(i+1)*4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x:int.from_bytes(x,'big'), set(sbytes[i:i+2] for i in range(0,len(sbytes),2)))) # integer values for 2-byte codes from sbox, will be explained shortly sboxes = [int.from_bytes(i,'big') for i in sboxes] data = key_final_dec(key1, ciphertext) # converting intermediate decryption to 128 bit ints data_int = [] for i in range(0,len(data),16): data_int.append(int.from_bytes(data[i:i+16],'big')) # we know the sbox already constraints = [sboxmap[i]==sboxes[i] for i in range(128)] for i in range(len(data)//64): four_code = sboxmap[flag[i]] # splitting 64 bit quantity to 16 bit individual sbox codes four_code_parts = [Extract(16*i+15,16*i,four_code) for i in range(3,-1,-1)] # for each code, matching aes_encryption with the observed value for a,b in zip(data_int[4*i:4*i+4], four_code_parts): constraints.append(aes_encryption(b)==a) # last but not least, aes_encryption(i) is unique for each plaintext # how would z3 know? Distinct function encodes them appropriately to # be distinct constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) for m in all_smt(solver, flag): # lets check for all satisfying flags (in case there are more than one # possible mappings and we will rule out invalid ones in that scenario? flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len(Counter(data[i:i+64] for i in range(0,len(data),64))) print(flag_bytes) Flag After running the script, we finally get our flag! b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU' And it turns out to be the only satisfying assignment. Turns out if there were repeated characters in the flag, we will get multiple possible satisfying values. So the admins have not been so cheeky afterall Full script Note that it takes a couple of seconds to find the z3 model import random from Crypto.Cipher import AES from collections import Counter from tqdm import tqdm from z3 import * import sys def all_smt(s, initial_terms): def block_term(s, m, t): s.add(t != m.eval(t)) def fix_term(s, m, t): s.add(t == m.eval(t)) def all_smt_rec(terms): if sat == s.check(): m = s.model() yield m for i in range(len(terms)): s.push() block_term(s, m, terms[i]) for j in range(i): fix_term(s, m, terms[j]) yield from all_smt_rec(terms[i:]) s.pop() yield from all_smt_rec(list(initial_terms)) with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i + 8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def unshuffle(data_list, shuffle_order): res = [None] * len(data_list) for i, v in enumerate(shuffle_order): res[v] = data_list[i] return res def test_unshuffle(): random_text = list(random.randbytes(16 * 100)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(10) random.shuffle(random_text_shuffled) random.seed(10) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text test_unshuffle() def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data def test_key_final_dec(): random_text = random.randbytes(16 * 100) assert key_final_dec(10, key_final_enc(10, random_text)) == random_text test_key_final_dec() for key1 in tqdm(range(2**15), desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i + 16] for i in range(0, len(data), 16)) if len(substitutions) != len(data) // 16: print("pid =", key1) break codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i * 4:(i + 1) * 4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x: int.from_bytes(x, 'big'), set( sbytes[i:i + 2] for i in range(0, len(sbytes), 2)))) sboxes = [int.from_bytes(i, 'big') for i in sboxes] data = key_final_dec(key1, ciphertext) data_int = [] for i in range(0, len(data), 16): data_int.append(int.from_bytes(data[i:i + 16], 'big')) flag = [BitVec('flag_' + str(i), 7) for i in range(len(data) // 64)] sboxmap = Array('sbox', BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES', BitVecSort(16), BitVecSort(128)) constraints = [sboxmap[i] == sboxes[i] for i in range(128)] for i in range(len(data) // 64): four_code = sboxmap[flag[i]] four_code_parts = [Extract(16 * i + 15, 16 * i, four_code) for i in range(3, -1, -1)] for a, b in zip(data_int[4 * i:4 * i + 4], four_code_parts): constraints.append(aes_encryption(b) == a) constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) # if solver.check() == sat: # m = solver.model() for m in all_smt(solver, flag): flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len( Counter(data[i:i + 64] for i in range(0, len(data), 64))) print(flag_bytes) else: print("failed to solve") Alternate Solution by teammate (Utaha#6878) All due regards to him for solving the challenge while I was stuck over finding key1 XD All parts will be almost same except the substitution solving part, which he did by manual bruteforcing i.e. recursively enumerating all mappings and backtracking on contradictions mp = dict() codes = sum([[i, i] for i in range(256)], start=[]) # notice that the range is changed from [0xb0, 0x1b0) to [0, 256). # It's just for relabeling. random.seed(key1) random.shuffle(codes) sboxes = [codes[i*4:(i+1)*4] for i in range(128)] def match(a, b): """ equate two objects elementwise ignoring if the entry is -1 """ for x, y in zip(a, b): if x == -1 or y == -1: continue if x != y: return False return True answers = [] def getFlag(cip, sboxes, mp): # get the flag based on current mapping, unknown char will be shown as '?' res = [] for c in cip: afterMap = [mp.get(x, -1) for x in c] found = False for i, s in enumerate(sboxes): if s == afterMap: res.append(i) found = True break if not found: res.append(ord('?')) return bytes(res) def brute(cip, sboxes, mp): """ cip and sboxes remain unchanged throughout the recursive call, but I feel bad using global varaibles. """ if DEBUG: print(getFlag(cip, sboxes, mp)) # check is finished isFinished = True for c in cip: if all(x in mp for x in c): pass else: isFinished = False if isFinished: answers.append(getFlag(cip, sboxes, mp)) print("Found an answer!!!!!!!") return # try matching isContradiction = False mp = mp.copy() # Find the one with least possible matches. min_pos = 256 index = -1 for idx, c in enumerate(cip): afterMap = [mp.get(x, -1) for x in c] if -1 not in afterMap: continue matches = [s for s in sboxes if match(s, afterMap)] if len(matches) == 0: isContradiction = True break if min_pos &gt; len(matches): index = idx min_pos = len(matches) if isContradiction: return # now bruteforce all possibilities assert index != -1 afterMap = [mp.get(x, -1) for x in cip[index]] matches = [s for s in sboxes if match(s, afterMap)] for m in matches: for x, y in zip(cip[index], m): mp[x] = y brute(cip, sboxes, mp) # This is based on the repetition for _ in [132, 197]: mp = {35: 224, 109: 144, 4: _} brute(cip, sboxes, mp) print("Answers:") answers = list(set(answers)) for x in answers: print(b"sdctf{" + x + b"}") # The fourth one is the actual answer Ciphertext repetition: [4, 5, 4, 6] [34, 35, 36, 35] [109, 60, 110, 109] Sbox repetition: [132, 93, 132, 211] [197, 32, 197, 248] [144, 86, 67, 144] [165, 224, 27, 224] Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Answers: b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' full script in solve2.py]]></summary></entry><entry><title type="html">Contributions</title><link href="https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/2021-04-08-contributions" rel="alternate" type="text/html" title="Contributions" /><published>2021-04-08T00:00:00+05:30</published><updated>2021-04-08T00:00:00+05:30</updated><id>https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/contributions</id><content type="html" xml:base="https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/2021-04-08-contributions"><![CDATA[<p>This is an open-sourced website hosted on github pages!<br />
If you wish to contribute or have a cool idea to share or even a cool challenge which can be put up as an assignment, this is the correct page you are looking at.
<!--more--></p>

<h2 id="contributing-as-a-collaborator">Contributing as a collaborator</h2>
<p>This repository uses jekyll theme <a href="https://tianqi.name/jekyll-TeXt-theme/docs/en/quick-start">TeXt</a>, check out the documentation for features and syntax.<br />
All the posts are stored in <a href="../_posts">_posts</a> directory, creating a file <code class="language-plaintext highlighter-rouge">YYYY-MM-DD-name.md</code> creates a url <code class="language-plaintext highlighter-rouge">/YYYY/MM/DD/name.html</code> in the github pages.<br />
To create a new post, just create a new file of the specified format.</p>

<h3 id="not-a-collaborator">Not a collaborator?</h3>
<p>Create a fork and issue a pull request with the repository. Make sure the branch you are working on is updated with the master branch. If you feel you would be a regular contributor, just feel free to let us know so that we can add you as collaborator!</p>

<h3 id="not-sure-if-you-want-to-publish-directly">Not sure if you want to publish directly?</h3>
<p>Create the same file with specified format in <a href="../_drafts">_drafts</a> (create if directory not available)</p>

<h3 id="showcase-your-work">Showcase your work</h3>
<p>You can showcase your work by having an author badge at the bottom which can be configured to display your profile (name, bio, github, twitter, linkedin etc).
Just navigate to <a href="_data/authors.yml">_data/authors.yml</a> and append your details (take hints from pre existing author details).</p>

<blockquote>
  <p>Note: Undesired files (not to be shown on the website) or paths should be added in the <code class="language-plaintext highlighter-rouge">exclude</code> variable in <a href="../_config.yml">_config.yml</a></p>
</blockquote>

<h2 id="front-matter"><a href="https://jekyllrb.com/docs/front-matter/">Front-matter</a></h2>
<p>Each post page has a beginning element called frontmatter which is enclosed in <code class="language-plaintext highlighter-rouge">---</code><br />
This yaml is configuration of the current page.<br />
Example</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
tags: introduction assignment
aside:
  toc: true
sidebar:
  nav: layouts
excerpt_separator: &lt;!--more--&gt;
author: deuterium
key: assignment000001
---
</code></pre></div></div>

<p>Some of the tags have been explained below,</p>

<table>
  <thead>
    <tr>
      <th>Tag</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>author</td>
      <td>The name of the article author as defined in <a href="https://github.com/CSEA-IITB/IITBreachers-wiki/tree/master/_data/authors.yml">_data/authors.yml</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>tags</td>
      <td>Space separated list of tags to categorize the page</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>aside</td>
      <td>For providing table of contents on right side of screen, autogenerated from page contents</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>sidebar</td>
      <td>For providing sidebar navigation to across articles, can be defined in <a href="https://github.com/CSEA-IITB/IITBreachers-wiki/tree/master/_data/navigation.yml">_data/navigation.yml</a> (needs to be defined beforehand)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>key</td>
      <td>A unique key to the page (required for loading comments)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>excerpt_separator</td>
      <td>An html tag <code class="language-plaintext highlighter-rouge">&lt;!--more--&gt;</code> to specify till where the text of artcle needs to be taken as the excerpt of the article</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>sha256hash</td>
      <td>To be used in assignment tasks. Just specify the sha256 of the flag.</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>mathjax</td>
      <td><code class="language-plaintext highlighter-rouge">true</code> enables mathjax syntax</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>mathjax_autoNumber</td>
      <td>Autonumbers the equations</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>mermaid</td>
      <td><code class="language-plaintext highlighter-rouge">true</code> enables mermaid js (very handy for quick diagrams)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>chart</td>
      <td><code class="language-plaintext highlighter-rouge">true</code> enables char.js on the page</td>
    </tr>
  </tbody>
</table>

<p>Check out other features in <a href="https://tianqi.name/jekyll-TeXt-theme/docs/en/quick-start">documentation</a></p>

<h2 id="creating-an-assignment">Creating an assignment</h2>
<p>Assignment will be just another article page, with tasks in it.<br />
The files required for the task need to be put into <a href="assignemts">assignments</a> directory in a directory which is name of the article.<br />
For each task, calculate the sha256 of the flag and put it in the <code class="language-plaintext highlighter-rouge">sha256hash</code> array in frontmatter.<br />
Put the tags</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{% assign index = 0 %}
{% include checkflag.html %}
</code></pre></div></div>
<p>To specify index of the task and include a flag input box!<br />
Check out <a href="https://github.com/deut-erium/ctf-tutorials/blob/master/_posts/2021-07-04-what%20are%20assignments.md">what are assignments.md</a> for an example.</p>

<p>Well thats all it takes to contribute and publish your article :smile:<br />
Expecting cool contributions! Who knows it may be your shot to learn writing and enhance your communication :wink:</p>

<p>Let me know if something is missing or unclear</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="introduction" /><category term="contribution" /><summary type="html"><![CDATA[This is an open-sourced website hosted on github pages! If you wish to contribute or have a cool idea to share or even a cool challenge which can be put up as an assignment, this is the correct page you are looking at.]]></summary></entry><entry><title type="html">Welcome</title><link href="https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/2021-04-08-welcome" rel="alternate" type="text/html" title="Welcome" /><published>2021-04-08T00:00:00+05:30</published><updated>2021-04-08T00:00:00+05:30</updated><id>https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/welcome</id><content type="html" xml:base="https://deut-erium.github.io/ctf-writeups-2021/ctf-writeups-2022/2021-04-08-welcome"><![CDATA[<p>Welcom to my CTF-writeups page for 2021. It will mostly contain the writeups to the CTFs in 2021 which I played, though the major
content would be related to cryptography, but I do sometimes take a look at Reverse Engineering and Miscellaneous stuff</p>

<p>Welcome to my personal blog about cybersecurity and computers in general where I host cool challenges (aka assignments) too
<!--more--></p>

<h2 id="need-help">Need Help?</h2>
<p>Always feel free to DM(direct message) on <a href="https://discord.com/new">discord</a>, Username: deuterium#1689.
Or any other convenient medium of choice.<br />
Not even on getting stuck, if you solve a challenge, you can brag about it or discuss the way you solved it!</p>

<p>HACK THE PLANET :metal: :metal: :metal:</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="welcome" /><category term="introduction" /><summary type="html"><![CDATA[Welcom to my CTF-writeups page for 2021. It will mostly contain the writeups to the CTFs in 2021 which I played, though the major content would be related to cryptography, but I do sometimes take a look at Reverse Engineering and Miscellaneous stuff Welcome to my personal blog about cybersecurity and computers in general where I host cool challenges (aka assignments) too]]></summary></entry></feed>